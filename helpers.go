package dnet

import (
	"strings"
	"time"

	"github.com/dilungasr/radi"
)

// AuthLink validates and authenticates verification link.
//
// link: represents the link from the client generated by the Link () function.
//It returns user ID if succeeds.
//
//status: indicates the results of the link validation. Where,
//
// 0 means link expired
//
// 1 stands for bad request i.e client side has sent the wrong link
//
// 2 means everything is fine! and with this status you can get the user ID.
func AuthLink(link string) (userID, linkID string, status int) {
	plainLink, ok := radi.Decrypt(link, Router1.ticketSecrete, Router1.ticketIV)

	if !ok {
		return userID, linkID, 1
	}

	linkParts := strings.Split(plainLink, ",")

	if len(linkParts) != 3 {
		return userID, linkID, 1
	}

	expireTimeString := linkParts[2]
	userID = linkParts[0]
	linkID = linkParts[1]

	expireTime, err := time.Parse(time.RFC3339, expireTimeString)
	if err != nil {
		return userID, linkID, 1
	}

	//check if the link has expired
	if time.Now().Local().After(expireTime) {
		// remove the ticket from the router
		return userID, linkID, 0
	}

	return userID, linkID, 2
}

// NewLink generates  a link to use for user verification.
//
// ID is a Unique identifier stored in the link througth aes encryption.
//
// minutes is a life time of the link in minutes i.e after that amount of time the link becomes expired.
//Default time is 60 minutes
func NewLink(userID, linkID string, minutes ...time.Duration) (link string, err error) {

	// default time is 1 hour
	if len(minutes) == 0 {
		minutes = []time.Duration{60}
	}

	expireTimeBytes, err := time.Now().Local().Add(minutes[0] * time.Minute).MarshalText()
	if err != nil {
		return "", err
	}

	expireTimeString := string(expireTimeBytes)

	return radi.Encrypt(userID+","+linkID+","+expireTimeString, Router1.ticketSecrete, Router1.ticketIV), nil
}

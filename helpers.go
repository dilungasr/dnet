package dnet

import (
	"strings"
	"time"

	"github.com/dilungasr/radi"
)

// AuthLink validates and authenticates verification link.
//
// link: represents the link from the client generated by the Link () function.
//It returns user ID if succeeds.
//
//status: indicates the results of the link validation. Where,
//
// 0 means link expired
//
// 1 stands for bad request i.e client side has sent the wrong link
//
// 2 means everything is fine! and with this status you can get the user ID.
func AuthLink(link string) (userID, linkID string, status int) {
	plainLink, ok := radi.Decrypt(link, router.ticketSecrete, router.ticketIV)

	if !ok {
		return userID, linkID, 1
	}

	linkParts := strings.Split(plainLink, ",")

	if len(linkParts) != 3 {
		return userID, linkID, 1
	}

	expireTimeString := linkParts[2]
	userID = linkParts[0]
	linkID = linkParts[1]

	expireTime, err := time.Parse(time.RFC3339, expireTimeString)
	if err != nil {
		return userID, linkID, 1
	}

	//check if the link has expired
	if time.Now().Local().After(expireTime) {
		// remove the ticket from the router
		return userID, linkID, 0
	}

	return userID, linkID, 2
}

// NewLink generates  a link to use for user verification.
//
// ID is a Unique identifier stored in the link througth aes encryption.
//
// minutes is a life time of the link in minutes i.e after that amount of time the link becomes expired.
//Default time is 60 minutes
func NewLink(userID, linkID string, minutes ...time.Duration) (link string, err error) {

	// default time is 1 hour
	if len(minutes) == 0 {
		minutes = []time.Duration{60}
	}

	expireTimeBytes, err := time.Now().Local().Add(minutes[0] * time.Minute).MarshalText()
	if err != nil {
		return "", err
	}

	expireTimeString := string(expireTimeBytes)

	return radi.Encrypt(userID+","+linkID+","+expireTimeString, router.ticketSecrete, router.ticketIV), nil
}

//contexts groups external context and  inner context as type contrains for contexts
type contexts interface {
	*EContext | *Ctx
}

// prepareRes prepares to send to the clients
func prepareRes[T contexts](c T, funcName string, statusAndData []interface{}) response {
	dataIndex := 0
	statusCode := 200

	// take user dataIndex from the statusAndCode and assign them to the above variables
	assignData(&dataIndex, &statusCode, statusAndData, funcName)

	action, ctxID := "", ""

	// test if it's an external context
	ectx, ok := any(c).(*EContext)
	if ok {
		action = ectx.action
		ctxID = ectx.ID
	} else {
		//  test if it's an inner context
		ctx, ok := any(c).(*Ctx)
		if ok {
			action = ctx.action
			ctxID = ctx.ID
		}
	}

	// return the prepared response
	return response{action, statusCode, statusAndData[dataIndex], ctxID}
}
